import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  OneToMany,
  AfterInsert,
  AfterUpdate,
  BeforeRemove,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
  OneToOne,
} from "typeorm";
import { Task } from "./Task";
import { User } from "./User";
import { FileItem } from "./FileItem";
import { ResourceSyncService } from "../service/resourceSyncService";
import { ResourceType } from "../type/ResourceType";
import { SubmissionType } from "../type/SubmissionType";
import { TaskStatus } from "./TaskStatus";
import { TaskCompletionFile } from "./TaskCompletionFile";
import { AppDataSource } from "../data-source";

@Entity({ name: "SubtaskSet" })
export class Subtask {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  title!: string;

  @Column({ type: "text", nullable: true })
  description!: string | null;

  @ManyToOne(() => TaskStatus, (status) => status.subtasks, {
    nullable: true,
  })
  status!: TaskStatus | null;

  @Column({ type: "date", nullable: true })
  startDate!: Date | null;

  @Column({ type: "date", nullable: true })
  endDate!: Date | null;

  @Column({ type: "date", nullable: true })
  submissionDate!: Date | null;

  @Column({
    type: "enum",
    enum: SubmissionType,
    default: SubmissionType.SIMPLE_MARK,
  })
  submissionType!: string;

  @ManyToOne(() => User, { nullable: true })
  assignee!: User | null;

  @ManyToOne(() => Task, (task) => task.subtasks, { onDelete: "CASCADE" })
  task!: Task;

  @Column({ type: "int", default: 0 })
  ordinal!: number;

  @Column({ default: false })
  autoGenerated!: boolean;

  @Column({ type: "uuid", nullable: true })
  forParticipant!: string | null; // ID of the participant this task is for (null if not applicable). Is needed to identify the subtasks to be deleted in case participant is removed from the project

  @OneToOne(() => TaskCompletionFile, (file) => file.subtask, {
    nullable: true,
    onDelete: "SET NULL",
  })
  @JoinColumn()
  taskCompletionFile!: TaskCompletionFile | null;

  @CreateDateColumn()
  createdOn!: Date;

  @UpdateDateColumn()
  updatedOn!: Date;

  getDetails() {
    return {
      id: this.id,
      title: this.title,
      description: this.description,
      status: this.status?.key,
      submissionType: this.submissionType,
      assigneeId: this.assignee?.id,
      taskId: this.task?.id,
      ordinal: this.ordinal,
      startDate: this.startDate,
      endDate: this.endDate,
      submissionDate: this.submissionDate,
      createdOn: this.createdOn,
      updatedOn: this.updatedOn,
      taskCompletionFile: this.taskCompletionFile?.getDetails(),
    };
  }

  @AfterInsert()
  @AfterUpdate()
  async createResource() {
    if (this.task) {
      const resourceService = new ResourceSyncService();

      const parentResourceId = (
        await resourceService.findResource(ResourceType.TASK, this.task?.id)
      )?.id;

      const resource = await resourceService.createOrUpdateResource(
        ResourceType.SUBTASK,
        this.id,
        parentResourceId
      );

      await resourceService.createOrUpdateCorrespondingFolder(
        resource,
        this.title
      );
    }
  }

  @BeforeRemove()
  async deleteResource() {
    const resourceService = new ResourceSyncService();
    await resourceService.deleteResource(ResourceType.SUBTASK, this.id);
  }
}
